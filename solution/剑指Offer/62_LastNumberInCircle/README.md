## [圆圈中最后剩下的数字](https://www.acwing.com/problem/content/78/)

### 题目描述
`0, 1, …, n-1` 这 `n `个数字 `(n>0)` 排成一个圆圈，从数字 `0` 开始每次从这个圆圈里删除第 `m` 个数字。

求出这个圆圈里剩下的最后一个数字。

**样例**
```
输入：n=5 , m=3

输出：3
```

### 解法
#### 解法一
利用循环数组存放每个数字，每走一步，判断对应位置的数是否是 `-1`，`-1` 的话不计步数，这样一直走 `m` 步。将该位数字置为 `-1`。

当共有 `n-1` 个数被置为 `-1` 时，输出唯一的不为 `-1` 的那个数。

说明：

- 构建循环链表也可以，每走 `m` 步，把所在节点删掉。最后剩下一个节点时返回。
- 这种解法每删除一个数字需要 `m` 步计算，共有 `n` 个数字，因此总的时间复杂度为 `O(mn)`，空间复杂度为 `O(n)`。

```java
/**
 * @author bingo
 * @since 2018/12/13
 */

class Solution {

    /**
     * 求圆圈最后一个数字
     *
     * @param n n个数 [0..n-1]
     * @param m 每次删除第 m 个数
     * @return 最后一个数字
     */
    public int lastRemaining(int n, int m) {
        int cnt = 0;
        int s = -1;
        int[] nums = new int[n];
        for (int i = 1; i < n; ++i) {
            nums[i] = i;
        }

        int e = -1;
        while (cnt < n - 1) {
            int i = 0;
            while (i < m) {
                e = (e + 1) % n;
                if (nums[e] != -1) {
                    ++i;
                }
            }

            ++cnt;
            nums[e] = -1;
            s = e;
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != -1) {
                return nums[i];
            }
        }
        return 0;
    }
}
```

#### 解法二
我们这样分析：

第一次被删除的圆圈的编号是 `m-1`。那么剩下的数字依次是：
```
0   1   2   3  ...  m-2   m  ...  n-1
```

由于下一次（共有 `n-1` 个数）是从 m 开始，因此我们对 m 的编号改为 0，依次改：
```
old ->  new

m   ->  0
m+1 ->  1
m+2 ->  2
.
.
.
n-1 ->  n-1-m
0   ->  n-m
1   ->  n-m+1
.
.
.
m-2 ->  n-2
```

我们假设子问题 `x'` 是最终解，那么对应到原问题 `x` 应该是什么呢？
```
new ->  old

0   ->  m
1   ->  m+1
2   ->  m+2
.
.
.
n-1-m   ->  n-1
n-m ->  0
n-m+1   ->  1
.
.
.
n-2 ->  m-2

x'  ->  x
```

```
x = (x' + m) % n
```

所以就有一个递推式：
```
f(i) = (f(i - 1) + m) % i;
```

算法的时间复杂度为 `O(n)`，空间复杂度为 `O(1)`。

```java
/**
 * @author bingo
 * @since 2018/12/13
 */

class Solution {

    /**
     * 求圆圈最后一个数字
     *
     * @param n n个数 [0..n-1]
     * @param m 每次删除第 m 个数
     * @return 最后一个数字
     */
    public int lastRemaining(int n, int m) {
        if (n < 1 || m < 1) {
            return -1;
        }
        int res = 0;
        for (int i = 2; i <= n; ++i) {
            res = (res + m) % i;
        }
        return res;
    }
}
```


### 测试用例
1. 功能测试（输入的 m 小于 n，比如从最初有 5 个数字的圆圈中每次删除第 2、3 个数字；输入的 m 大于或者等于 n，比如从最初有 6 个数字的圆圈中每次删除第 6、7 个数字）；
2. 特殊输入测试（圆圈中有 0 个数字）；
3. 性能测试（从最初有 4000 个数字的圆圈中每次删除第 997 个数字）。